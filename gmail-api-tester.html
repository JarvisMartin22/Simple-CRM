<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gmail API Functionality Tester</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #0070f3;
        }
        .section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #eaeaea;
            border-radius: 8px;
            background: #fafafa;
        }
        .test-button {
            background-color: #0070f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background-color: #0056b3;
        }
        .test-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .data-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .data-container pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .scope-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            padding: 8px;
            background: white;
            border-radius: 4px;
        }
        .scope-used {
            background-color: #d4edda;
        }
        .scope-unused {
            background-color: #f8d7da;
        }
        .scope-potential {
            background-color: #fff3cd;
        }
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #0070f3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .endpoint-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .endpoint-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        .endpoint-card h4 {
            margin-top: 0;
            color: #333;
        }
        .code-block {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        .config-section {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        #connectionStatus {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="connectionStatus" class="status info">Checking Gmail Connection...</div>
    
    <h1>üîß Gmail API Functionality Tester</h1>
    <p>Comprehensive testing tool for all Gmail integration functionality in your Simple-CRM application.</p>

    <div class="config-section">
        <h3>‚öôÔ∏è Configuration</h3>
        <div>
            <label for="supabaseUrl">Supabase URL:</label>
            <input type="text" id="supabaseUrl" style="width: 400px; margin: 5px;" placeholder="https://your-project.supabase.co">
        </div>
        <div>
            <label for="supabaseKey">Supabase Anon Key:</label>
            <input type="text" id="supabaseKey" style="width: 400px; margin: 5px;" placeholder="Your anon key">
        </div>
        <div>
            <label for="userEmail">Email:</label>
            <input type="email" id="userEmail" style="width: 300px; margin: 5px;" placeholder="Your email">
            <label for="userPassword">Password:</label>
            <input type="password" id="userPassword" style="width: 200px; margin: 5px;" placeholder="Your password">
        </div>
        <button class="test-button" onclick="saveConfig()">Save Configuration</button>
        <button class="test-button" onclick="loadConfig()">Load from Local Storage</button>
        <button class="test-button" onclick="signIn()">Sign In</button>
        <button class="test-button" onclick="signOut()">Sign Out</button>
    </div>

    <div class="section">
        <h2>üìä Google Console Scopes Analysis</h2>
        <p>Your configured scopes and their usage in the CRM:</p>
        <div id="scopeAnalysis">
            <div class="scope-item scope-used">
                <strong>‚úÖ auth/gmail.send</strong> - Used by <code>send-email</code> function
            </div>
            <div class="scope-item scope-used">
                <strong>‚úÖ auth/gmail.readonly</strong> - Used by <code>gmail-sync</code>, email tracking
            </div>
            <div class="scope-item scope-used">
                <strong>‚úÖ auth/contacts.readonly</strong> - Used by <code>gmail-contacts</code>
            </div>
            <div class="scope-item scope-used">
                <strong>‚úÖ auth/contacts.other.readonly</strong> - Used by <code>gmail-contacts</code>
            </div>
            <div class="scope-item scope-used">
                <strong>‚úÖ auth/user.emails.read</strong> - Used by <code>gmail-auth</code>
            </div>
            <div class="scope-item scope-potential">
                <strong>‚ö†Ô∏è auth/gmail.modify</strong> - Could be used for email management (archive, labels)
            </div>
            <div class="scope-item scope-potential">
                <strong>‚ö†Ô∏è auth/gmail.labels</strong> - Could be used for email organization
            </div>
            <div class="scope-item scope-potential">
                <strong>‚ö†Ô∏è auth/gmail.metadata</strong> - Could be used for enhanced email analysis
            </div>
            <div class="scope-item scope-potential">
                <strong>‚ö†Ô∏è auth/user.phonenumbers.read</strong> - Could enhance contact data
            </div>
            <div class="scope-item scope-unused">
                <strong>‚ùå auth/gmail.addons.current.message.action</strong> - Gmail Add-on specific
            </div>
            <div class="scope-item scope-unused">
                <strong>‚ùå auth/profile.emails.read</strong> - Duplicate of user.emails.read
            </div>
        </div>
    </div>

    <div class="section">
        <h2>üöÄ ENHANCED Stealth Email Tracking Tests</h2>
        <p><strong>NEW:</strong> Test the enhanced stealth tracking capabilities that bypass Gmail's privacy protection.</p>
        
        <div class="endpoint-grid">
            <div class="endpoint-card">
                <h4>üïµÔ∏è Stealth Email Send</h4>
                <p>Send emails with invisible tracking that bypasses Gmail blocks</p>
                <div>
                    <input type="email" id="stealthTestEmail" placeholder="Recipient email" style="width: 100%; margin: 5px 0;">
                    <input type="text" id="stealthTestSubject" placeholder="Email subject" value="CRM Enhanced Test" style="width: 100%; margin: 5px 0;">
                    <textarea id="stealthTestBody" placeholder="Email body (HTML)" rows="3" style="width: 100%; margin: 5px 0;">
<h2>Enhanced CRM Test Email</h2>
<p>This email uses enhanced stealth tracking features:</p>
<ul>
    <li>Invisible tracking pixel with absolute positioning</li>
    <li>Personal Gmail-like headers</li>
    <li>Auto-labeling for organization</li>
    <li>Link tracking: <a href="https://example.com">Test Link</a></li>
</ul>
<p>Test opening and clicking to verify tracking works!</p>
                    </textarea>
                </div>
                <button class="test-button" onclick="testStealthEmailSend()">üöÄ Send Enhanced Email</button>
                <div id="stealthSendResult" class="data-container" style="display:none;"></div>
            </div>

            <div class="endpoint-card">
                <h4>üè∑Ô∏è Gmail Labels Test</h4>
                <p>Test automatic label creation and application</p>
                <button class="test-button" onclick="testGmailLabelsFeature()">Test Label Creation</button>
                <button class="test-button" onclick="listGmailLabels()">List All Labels</button>
                <div id="labelsResult" class="data-container" style="display:none;"></div>
            </div>

            <div class="endpoint-card">
                <h4>üìä Enhanced Analytics</h4>
                <p>Test improved tracking data collection</p>
                <button class="test-button" onclick="testEnhancedAnalytics()">Test Analytics</button>
                <button class="test-button" onclick="simulateEmailOpens()">Simulate Opens</button>
                <div id="enhancedAnalyticsResult" class="data-container" style="display:none;"></div>
            </div>

            <div class="endpoint-card">
                <h4>üîç Tracking Verification</h4>
                <p>Verify stealth tracking implementation</p>
                <button class="test-button" onclick="verifyTrackingPixel()">Verify Pixel Stealth</button>
                <button class="test-button" onclick="testLinkTracking()">Test Link Tracking</button>
                <div id="trackingVerifyResult" class="data-container" style="display:none;"></div>
            </div>
        </div>
        
        <div class="status info">
            <strong>‚ú® Enhanced Features:</strong>
            <ul>
                <li><strong>Stealth Pixel:</strong> Positioned with absolute positioning for invisibility</li>
                <li><strong>Personal Headers:</strong> X-Mailer: Gmail, X-Priority: 3 for natural appearance</li>
                <li><strong>Auto-Labeling:</strong> CRM-Sent and CRM-Campaign-[ID] labels</li>
                <li><strong>Improved Placement:</strong> Tracking pixel inserted before </body> tag</li>
                <li><strong>Better Deliverability:</strong> Gmail-like headers reduce spam filtering</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>üîó Authentication & Connection</h2>
        <button class="test-button" onclick="testGmailConnection()">
            <span id="connectionLoader" style="display: none;" class="loading"></span>
            Test Gmail Connection
        </button>
        <button class="test-button" onclick="refreshGmailToken()">Refresh Token</button>
        <button class="test-button" onclick="viewTokenDetails()">View Token Details</button>
        <div id="connectionResult" class="data-container" style="display: none;"></div>
    </div>

    <div class="endpoint-grid">
        <div class="endpoint-card">
            <h3>üìß Email Sending</h3>
            <h4>Endpoint: <code>/functions/v1/send-email</code></h4>
            <p><strong>Scope:</strong> gmail.send</p>
            <button class="test-button" onclick="testSendEmail()">Test Send Email</button>
            <button class="test-button" onclick="testEmailWithTracking()">Test with Tracking</button>
            <div class="code-block">
                POST body: { userId, to, subject, body, trackOpens, trackClicks }
            </div>
            <div id="sendEmailResult" class="data-container" style="display: none;"></div>
        </div>

        <div class="endpoint-card">
            <h3>üë• Contacts Import</h3>
            <h4>Endpoint: <code>/functions/v1/gmail-contacts</code></h4>
            <p><strong>Scope:</strong> contacts.readonly, contacts.other.readonly</p>
            <button class="test-button" onclick="testContactsImport()">Test Contacts Import</button>
            <button class="test-button" onclick="testContactsPreview()">Test Contacts Preview</button>
            <div class="code-block">
                Headers: X-Gmail-Token, POST body: { integration_id, access_token }
            </div>
            <div id="contactsResult" class="data-container" style="display: none;"></div>
        </div>

        <div class="endpoint-card">
            <h3>üì¨ Email Sync</h3>
            <h4>Endpoint: <code>/functions/v1/gmail-sync</code></h4>
            <p><strong>Scope:</strong> gmail.readonly</p>
            <button class="test-button" onclick="testEmailSync()">Test Email Sync</button>
            <button class="test-button" onclick="testEmailMetadata()">Test Email Metadata</button>
            <div class="code-block">
                POST body: { userId, syncType: 'pull'|'push', forceSync }
            </div>
            <div id="syncResult" class="data-container" style="display: none;"></div>
        </div>

        <div class="endpoint-card">
            <h3>üìä Email Tracking</h3>
            <h4>Endpoints: <code>/functions/v1/email-tracker</code>, <code>/functions/v1/link-tracker</code></h4>
            <p><strong>Scope:</strong> gmail.readonly (for metadata)</p>
            <button class="test-button" onclick="testEmailTracking()">Test Email Tracking</button>
            <button class="test-button" onclick="testLinkTracking()">Test Link Tracking</button>
            <div class="code-block">
                GET: ?id={tracking_id} | ?id={link_id}&url={original_url}
            </div>
            <div id="trackingResult" class="data-container" style="display: none;"></div>
        </div>

        <div class="endpoint-card">
            <h3>üè∑Ô∏è Gmail Labels (Potential)</h3>
            <h4>Endpoint: <em>Not implemented yet</em></h4>
            <p><strong>Scope:</strong> gmail.labels</p>
            <button class="test-button" onclick="testLabelsAPI()">Test Labels API</button>
            <button class="test-button" onclick="createTestLabel()">Create Test Label</button>
            <div class="code-block">
                Direct Gmail API: /gmail/v1/users/me/labels
            </div>
            <div id="labelsResult" class="data-container" style="display: none;"></div>
        </div>

        <div class="endpoint-card">
            <h3>üì± Contact Phone Numbers (Potential)</h3>
            <h4>Endpoint: <em>Enhancement to contacts import</em></h4>
            <p><strong>Scope:</strong> user.phonenumbers.read</p>
            <button class="test-button" onclick="testPhoneNumbers()">Test Phone Numbers</button>
            <div class="code-block">
                Google People API: /v1/people/me?personFields=phoneNumbers
            </div>
            <div id="phoneResult" class="data-container" style="display: none;"></div>
        </div>
    </div>

    <div class="section">
        <h2>üß™ Integration Tests</h2>
        <p>Run comprehensive tests to validate all functionality:</p>
        <button class="test-button" onclick="runFullTest()">Run All Tests</button>
        <button class="test-button" onclick="runQuickTest()">Quick Health Check</button>
        <button class="test-button" onclick="exportTestResults()">Export Results</button>
        <div id="integrationTestResult" class="data-container" style="display: none;"></div>
    </div>

    <div class="section">
        <h2>üõ†Ô∏è Database Schema Analysis</h2>
        <p>Check if your database schema supports all the data we can retrieve:</p>
        <button class="test-button" onclick="analyzeSchema()">Analyze Database Schema</button>
        <button class="test-button" onclick="suggestSchemaUpdates()">Suggest Schema Updates</button>
        <div id="schemaResult" class="data-container" style="display: none;"></div>
    </div>

    <script>
        let supabaseUrl = '';
        let supabaseKey = '';
        let userToken = '';
        let currentIntegration = null;

        // Add message deduplication
        const processedCodes = new Set();
        
        window.addEventListener('message', async function(event) {
            // Verify the origin
            if (event.origin !== window.location.origin) {
                console.log('Ignoring message from unknown origin:', event.origin);
                return;
            }

            // Ignore React DevTools messages
            if (event.data?.source === 'react-devtools-content-script') {
                return;
            }
            
            if (event.data && event.data.type === 'GMAIL_AUTH_CODE') {
                const code = event.data.code;
                const state = event.data.state;
                
                // Check if we've already processed this code
                if (processedCodes.has(code)) {
                    console.log('Ignoring duplicate auth code');
                    return;
                }
                processedCodes.add(code);
                
                console.log('Processing auth code from callback, length:', code?.length);
                showStatus('Processing authorization...', 'info');
                
                // Verify state parameter to prevent CSRF attacks
                const savedState = localStorage.getItem('gmail_auth_state');
                if (state && savedState && state !== savedState) {
                    console.error('State parameter mismatch - possible CSRF attack');
                    showStatus('Authorization failed: Invalid state parameter', 'error');
                    showResult('connectionResult', {
                        status: 'Error',
                        message: 'Invalid state parameter - possible CSRF attack',
                        timestamp: new Date().toISOString()
                    }, 'error');
                    localStorage.removeItem('gmail_auth_state');
                    localStorage.removeItem('gmail_auth_timestamp');
                    return;
                }
                
                // Clear state after verification
                localStorage.removeItem('gmail_auth_state');
                localStorage.removeItem('gmail_auth_timestamp');
                
                try {
                    showResult('connectionResult', {
                        status: 'Processing',
                        message: 'Exchanging authorization code for tokens...',
                        timestamp: new Date().toISOString()
                    }, 'info');

                    console.log('Making token exchange request to:', `${supabaseUrl}/functions/v1/gmail-auth`);

                    const response = await fetch(`${supabaseUrl}/functions/v1/gmail-auth`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${userToken}`,
                            'apikey': supabaseKey
                        },
                        body: JSON.stringify({ code })
                    });

                    const data = await response.json();
                    console.log('Token exchange response:', {
                        status: response.status,
                        ok: response.ok,
                        provider: data.provider,
                        email: data.email,
                        hasAccessToken: !!data.access_token,
                        hasRefreshToken: !!data.refresh_token,
                        integration: data.integration
                    });
                    
                    if (response.ok) {
                        showStatus('Gmail Connected Successfully! ‚úÖ', 'success');
                        showResult('connectionResult', {
                            status: 'Success',
                            message: 'Authorization successful',
                            provider: data.provider,
                            email: data.email,
                            hasAccessToken: !!data.access_token,
                            hasRefreshToken: !!data.refresh_token,
                            expiresAt: data.expires_at,
                            integration: data.integration,
                            timestamp: new Date().toISOString()
                        }, 'success');
                        
                        // Add delay before checking connection
                        console.log('Waiting before checking connection status...');
                        try {
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            console.log('Checking connection status...');
                            await checkGmailConnection();
                        } catch (error) {
                            console.error('Error in delayed connection check:', error);
                            // Even if connection check fails, we're still connected since token exchange worked
                            showStatus('Gmail Connected (with warning) ‚ö†Ô∏è', 'warning');
                        }
                    } else {
                        console.error('Token exchange failed:', data);
                        showStatus('Failed to exchange code for tokens ‚ùå', 'error');
                        showResult('connectionResult', {
                            status: 'Error',
                            message: 'Failed to exchange authorization code',
                            error: data.error || 'Unknown error',
                            errorDetails: data.error_description || data.message,
                            responseStatus: response.status,
                            timestamp: new Date().toISOString()
                        }, 'error');
                    }
                } catch (error) {
                    console.error('Error exchanging code:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                    showResult('connectionResult', {
                        status: 'Error',
                        message: 'Exception during token exchange',
                        error: error.message,
                        stack: error.stack,
                        timestamp: new Date().toISOString()
                    }, 'error');
                }
            }
        });

        // Load configuration on page load
        window.onload = async function() {
            loadConfig();
            await checkGmailConnection();
            
            // Check for stored auth code from callback
            const storedCode = localStorage.getItem('gmail_auth_code');
            const storedTimestamp = localStorage.getItem('gmail_auth_timestamp');
            
            if (storedCode) {
                console.log('Found stored auth code, checking validity...');
                
                // Check if code is too old (5 minutes max)
                const timestamp = parseInt(storedTimestamp || '0', 10);
                const now = Date.now();
                const fiveMinutes = 5 * 60 * 1000;
                
                if (now - timestamp > fiveMinutes) {
                    console.log('Stored auth code is too old, removing');
                    localStorage.removeItem('gmail_auth_code');
                    localStorage.removeItem('gmail_auth_timestamp');
                    return;
                }
                
                try {
                    console.log('Processing stored auth code');
                    const response = await fetch(`${supabaseUrl}/functions/v1/gmail-auth`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${userToken}`,
                            'apikey': supabaseKey
                        },
                        body: JSON.stringify({ code: storedCode })
                    });

                    const data = await response.json();
                    console.log('Token exchange response:', data);
                    
                    if (response.ok) {
                        showStatus('Gmail Connected Successfully! ‚úÖ', 'success');
                        await checkGmailConnection();
                    } else {
                        showStatus('Failed to exchange code for tokens ‚ùå', 'error');
                    }
                    
                    // Always remove the code after attempting to use it
                    localStorage.removeItem('gmail_auth_code');
                    localStorage.removeItem('gmail_auth_timestamp');
                } catch (error) {
                    console.error('Error exchanging code:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                    // Remove the code if there was an error
                    localStorage.removeItem('gmail_auth_code');
                    localStorage.removeItem('gmail_auth_timestamp');
                }
            }
        };

        function saveConfig() {
            supabaseUrl = document.getElementById('supabaseUrl').value;
            supabaseKey = document.getElementById('supabaseKey').value;
            
            localStorage.setItem('gmail_tester_config', JSON.stringify({
                supabaseUrl,
                supabaseKey
            }));
            
            showStatus('Configuration saved!', 'success');
        }

        function loadConfig() {
            const config = localStorage.getItem('gmail_tester_config');
            const auth = localStorage.getItem('gmail_tester_auth');
            
            if (config) {
                const { supabaseUrl: url, supabaseKey: key } = JSON.parse(config);
                document.getElementById('supabaseUrl').value = url;
                document.getElementById('supabaseKey').value = key;
                supabaseUrl = url;
                supabaseKey = key;
                showStatus('Configuration loaded from storage', 'success');
            }

            if (auth) {
                const { access_token, expires_at } = JSON.parse(auth);
                if (access_token && new Date(expires_at) > new Date()) {
                    userToken = access_token;
                    checkGmailConnection();
                } else {
                    localStorage.removeItem('gmail_tester_auth');
                }
            }
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        function showResult(elementId, data, type = 'info') {
            const el = document.getElementById(elementId);
            el.style.display = 'block';
            el.className = `data-container ${type}`;
            
            if (typeof data === 'object') {
                el.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
            } else {
                el.innerHTML = `<pre>${data}</pre>`;
            }
        }

        async function checkGmailConnection() {
            if (!supabaseUrl || !supabaseKey || !userToken) {
                showStatus('Please configure settings and sign in first', 'warning');
                return;
            }

            try {
                console.log('Starting connection check...');
                
                // First get the user ID from the auth token
                console.log('Fetching user data...');
                const userResponse = await fetch(
                    `${supabaseUrl}/auth/v1/user`,
                    {
                        headers: {
                            'Authorization': `Bearer ${userToken}`,
                            'apikey': supabaseKey
                        }
                    }
                );

                const userData = await userResponse.json();
                console.log('User data response:', {
                    status: userResponse.status,
                    hasUserId: !!userData.id,
                    error: userData.error
                });

                if (!userData.id) {
                    console.error('No user ID in response:', userData);
                    showStatus('Not authenticated', 'error');
                    return;
                }

                console.log('Checking Gmail integration with:', {
                    url: `${supabaseUrl}/rest/v1/user_integrations`,
                    hasKey: !!supabaseKey,
                    userId: userData.id
                });

                const integrationResponse = await fetch(
                    `${supabaseUrl}/rest/v1/user_integrations?provider=eq.gmail&user_id=eq.${userData.id}&select=*`,
                    {
                        headers: {
                            'Authorization': `Bearer ${userToken}`,
                            'apikey': supabaseKey,
                            'Content-Profile': 'public',
                            'Content-Type': 'application/json'
                        }
                    }
                );

                console.log('Integration check response status:', integrationResponse.status);
                console.log('Integration check response headers:', Object.fromEntries(integrationResponse.headers.entries()));

                const responseText = await integrationResponse.text();
                console.log('Raw integration response:', responseText);

                let integrations;
                try {
                    integrations = JSON.parse(responseText);
                    console.log('Parsed integrations:', integrations);
                } catch (e) {
                    console.error('Failed to parse integration response:', e);
                    throw new Error('Failed to parse integration response: ' + e.message);
                }

                if (integrationResponse.ok) {
                    if (integrations && integrations.length > 0) {
                        currentIntegration = integrations[0];
                        console.log('Found integration:', {
                            provider: currentIntegration.provider,
                            email: currentIntegration.email,
                            userId: currentIntegration.user_id
                        });
                        showStatus('Gmail Connected ‚úÖ', 'success');
                        showResult('connectionResult', {
                            status: 'Connected',
                            provider: currentIntegration.provider,
                            email: currentIntegration.email,
                            hasAccessToken: !!currentIntegration.access_token,
                            hasRefreshToken: !!currentIntegration.refresh_token,
                            expiresAt: currentIntegration.expires_at,
                            created_at: currentIntegration.created_at,
                            updated_at: currentIntegration.updated_at,
                            user_id: currentIntegration.user_id
                        }, 'success');
                    } else {
                        console.log('No integrations found for user:', userData.id);
                        showStatus('Gmail Not Connected ‚ùå', 'error');
                        showResult('connectionResult', {
                            status: 'Not Connected',
                            message: 'No Gmail integration found in database',
                            timestamp: new Date().toISOString(),
                            user_id: userData.id
                        }, 'error');
                    }
                } else {
                    console.error('Integration check failed:', {
                        status: integrationResponse.status,
                        response: responseText
                    });
                    showStatus('Error checking integration', 'error');
                    showResult('connectionResult', {
                        status: 'Error',
                        statusCode: integrationResponse.status,
                        headers: Object.fromEntries(integrationResponse.headers.entries()),
                        error: responseText,
                        timestamp: new Date().toISOString(),
                        user_id: userData.id
                    }, 'error');
                }
            } catch (error) {
                console.error('Connection check error:', error);
                throw error; // Re-throw to be handled by caller
            }
        }

        async function testGmailConnection() {
            document.getElementById('connectionLoader').style.display = 'inline-block';
            
            try {
                // First check if we already have a valid integration
                if (currentIntegration && currentIntegration.access_token) {
                    // Try to use the existing token
                    try {
                        const response = await fetch('https://www.googleapis.com/oauth2/v1/userinfo', {
                            headers: {
                                'Authorization': `Bearer ${currentIntegration.access_token}`
                            }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            showResult('connectionResult', {
                                status: 'Connected',
                                message: 'Existing connection is valid',
                                userInfo: data,
                                integration: {
                                    provider: currentIntegration.provider,
                                    email: currentIntegration.email,
                                    expiresAt: currentIntegration.expires_at
                                }
                            }, 'success');
                            showStatus('Gmail Connected ‚úÖ', 'success');
                            document.getElementById('connectionLoader').style.display = 'none';
                            return;
                        }
                    } catch (error) {
                        console.log('Error checking existing token:', error);
                    }
                }
                
                // If we get here, we need to start a new auth flow
                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-auth`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({ 
                        test: true,
                        // Use the authorized redirect URI for the tester
                        redirectUri: "http://localhost:8080/auth-callback.html"
                    })
                });

                const data = await response.json();
                console.log('Auth test response:', data);
                
                if (response.ok && data.url) {
                    // Store state parameter for CSRF protection if provided
                    if (data.state) {
                        localStorage.setItem('gmail_auth_state', data.state);
                        localStorage.setItem('gmail_auth_timestamp', Date.now().toString());
                    }
                    
                    // Calculate popup position for center of screen
                    const width = 600;
                    const height = 700;
                    const left = window.screenX + (window.outerWidth - width) / 2;
                    const top = window.screenY + (window.outerHeight - height) / 2;
                    
                    // Open the auth URL in a popup window
                    const authPopup = window.open(
                        data.url, 
                        'gmail_auth', 
                        `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
                    );
                    
                    // Check if popup was blocked
                    if (!authPopup || authPopup.closed) {
                        showStatus('Popup was blocked. Please allow popups for this site.', 'error');
                        showResult('connectionResult', {
                            status: 'Error',
                            message: 'Popup was blocked. Please allow popups for this site.',
                            timestamp: new Date().toISOString()
                        }, 'error');
                        document.getElementById('connectionLoader').style.display = 'none';
                        return;
                    }
                    
                    showResult('connectionResult', {
                        status: 'Authorizing',
                        message: 'Please complete the authorization in the popup window',
                        redirectUri: data.redirectUri,
                        timestamp: new Date().toISOString()
                    }, 'info');
                    
                    // Monitor the popup window
                    const popupCheckInterval = setInterval(() => {
                        try {
                            if (!authPopup || authPopup.closed) {
                                clearInterval(popupCheckInterval);
                                document.getElementById('connectionLoader').style.display = 'none';
                                
                                // Check if the connection was successful by checking for updated data
                                setTimeout(checkGmailConnection, 1000);
                            }
                        } catch (e) {
                            // COOP policy might block access to window.closed
                            console.log('Error checking popup state:', e.message);
                            // We'll continue monitoring, and the timeout from checkGmailConnection will eventually check the status
                        }
                    }, 1000);
                } else {
                    showResult('connectionResult', {
                        status: 'Error',
                        error: data.error || 'Failed to start authorization',
                        response: data,
                        timestamp: new Date().toISOString()
                    }, 'error');
                    document.getElementById('connectionLoader').style.display = 'none';
                }
            } catch (error) {
                console.error('Connection test error:', error);
                showResult('connectionResult', {
                    status: 'Error',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
                document.getElementById('connectionLoader').style.display = 'none';
            }
        }

        async function refreshGmailToken() {
            if (!currentIntegration?.refresh_token) {
                showResult('connectionResult', 'No refresh token available', 'error');
                return;
            }

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-auth`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({ 
                        refresh_token: currentIntegration.refresh_token 
                    })
                });

                const data = await response.json();
                showResult('connectionResult', {
                    action: 'Token Refresh',
                    status: response.status,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

                if (response.ok) {
                    // Update current integration
                    currentIntegration.access_token = data.access_token;
                    currentIntegration.expires_at = data.expires_at;
                }

            } catch (error) {
                showResult('connectionResult', {
                    action: 'Token Refresh',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function viewTokenDetails() {
            if (!currentIntegration) {
                showResult('connectionResult', 'No Gmail integration found', 'error');
                return;
            }

            const tokenData = {
                provider: currentIntegration.provider,
                email: currentIntegration.email,
                hasAccessToken: !!currentIntegration.access_token,
                hasRefreshToken: !!currentIntegration.refresh_token,
                expiresAt: currentIntegration.expires_at,
                isExpired: new Date(currentIntegration.expires_at) < new Date(),
                scope: currentIntegration.scope,
                createdAt: currentIntegration.created_at,
                updatedAt: currentIntegration.updated_at
            };

            showResult('connectionResult', tokenData, 'info');
        }

        async function testSendEmail() {
            if (!currentIntegration) {
                showResult('sendEmailResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/send-email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({
                        userId: currentIntegration.user_id,
                        to: 'test@example.com',
                        subject: 'Test Email from CRM',
                        body: '<p>This is a test email from your CRM system.</p>',
                        trackOpens: false,
                        trackClicks: false
                    })
                });

                const data = await response.json();
                showResult('sendEmailResult', {
                    action: 'Send Email Test',
                    status: response.status,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('sendEmailResult', {
                    action: 'Send Email Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testEmailWithTracking() {
            if (!currentIntegration) {
                showResult('sendEmailResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/send-email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({
                        userId: currentIntegration.user_id,
                        to: 'test@example.com',
                        subject: 'Test Tracked Email from CRM',
                        body: '<p>This is a test email with tracking. <a href="https://example.com">Click here</a></p>',
                        trackOpens: true,
                        trackClicks: true
                    })
                });

                const data = await response.json();
                showResult('sendEmailResult', {
                    action: 'Send Tracked Email Test',
                    status: response.status,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('sendEmailResult', {
                    action: 'Send Tracked Email Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testContactsImport() {
            if (!currentIntegration) {
                showResult('contactsResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-contacts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'X-Gmail-Token': currentIntegration.access_token,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({
                        integration_id: currentIntegration.id,
                        access_token: currentIntegration.access_token,
                        refresh_token: currentIntegration.refresh_token,
                        include_no_email: false
                    })
                });

                const data = await response.json();
                showResult('contactsResult', {
                    action: 'Contacts Import Test',
                    status: response.status,
                    contactCount: data.contacts?.length || 0,
                    stats: data.stats,
                    sampleContact: data.contacts?.[0],
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('contactsResult', {
                    action: 'Contacts Import Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testContactsPreview() {
            if (!currentIntegration) {
                showResult('contactsResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                console.log('Testing contacts preview with integration:', {
                    hasToken: !!currentIntegration.access_token,
                    userId: currentIntegration.user_id,
                    tokenExpiry: currentIntegration.expires_at
                });

                // Check if token needs refresh
                const tokenExpiry = new Date(currentIntegration.expires_at);
                const now = new Date();
                if (tokenExpiry <= now) {
                    console.log('Token expired, attempting refresh...');
                    await refreshGmailToken();
                }

                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-contacts-preview`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({
                        accessToken: currentIntegration.access_token
                    })
                });

                const data = await response.json();
                console.log('Contacts preview response:', {
                    status: response.status,
                    headers: Object.fromEntries(response.headers.entries()),
                    data: data
                });

                if (!response.ok) {
                    throw new Error(data.error || `HTTP error! status: ${response.status}`);
                }

                showResult('contactsResult', {
                    action: 'Contacts Preview Test',
                    status: response.status,
                    success: data.success,
                    contactCount: data.data?.length || 0,
                    error: data.error,
                    timestamp: new Date().toISOString()
                }, data.success ? 'success' : 'error');

            } catch (error) {
                console.error('Contacts preview error:', error);
                showResult('contactsResult', {
                    action: 'Contacts Preview Test',
                    error: error.message,
                    details: error.toString(),
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testEmailSync() {
            if (!currentIntegration) {
                showResult('syncResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-sync`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({
                        userId: currentIntegration.user_id,
                        syncType: 'pull',
                        forceSync: false
                    })
                });

                const data = await response.json();
                showResult('syncResult', {
                    action: 'Email Sync Test',
                    status: response.status,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('syncResult', {
                    action: 'Email Sync Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testEmailMetadata() {
            if (!currentIntegration) {
                showResult('syncResult', 'Gmail not connected', 'error');
                return;
            }

            // Test direct Gmail API call for metadata
            try {
                console.log('Making Gmail API call with token:', {
                    hasAccessToken: !!currentIntegration.access_token,
                    tokenPrefix: currentIntegration.access_token?.substring(0, 10) + '...',
                    expiresAt: currentIntegration.expires_at
                });

                const response = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages?maxResults=5&q=is:unread', {
                    headers: {
                        'Authorization': `Bearer ${currentIntegration.access_token}`
                    }
                });

                const data = await response.json();
                showResult('syncResult', {
                    action: 'Email Metadata Test',
                    status: response.status,
                    messageCount: data.messages?.length || 0,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('syncResult', {
                    action: 'Email Metadata Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testEmailTracking() {
            try {
                const testId = 'test-tracking-' + Date.now();
                const functionUrl = `${supabaseUrl}/functions/v1/email-tracker?id=${testId}`;
                console.log('Testing email tracking with URL:', functionUrl);

                const response = await fetch(functionUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': supabaseKey,
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`
                    }
                }).catch(error => {
                    console.error('Fetch error details:', {
                        message: error.message,
                        cause: error.cause,
                        stack: error.stack
                    });
                    throw error;
                });

                console.log('Email tracking response:', {
                    status: response.status,
                    headers: Object.fromEntries(response.headers.entries()),
                    ok: response.ok
                });

                showResult('trackingResult', {
                    action: 'Email Tracking Test',
                    status: response.status,
                    trackingId: testId,
                    contentType: response.headers.get('Content-Type'),
                    url: functionUrl,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                console.error('Email tracking error:', error);
                showResult('trackingResult', {
                    action: 'Email Tracking Test',
                    error: error.message,
                    url: `${supabaseUrl}/functions/v1/email-tracker`,
                    supabaseUrl: supabaseUrl,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testLinkTracking() {
            try {
                const testId = 'test-link-' + Date.now();
                const testUrl = 'https://example.com';
                const functionUrl = `${supabaseUrl}/functions/v1/link-tracker?id=${testId}&url=${encodeURIComponent(testUrl)}`;
                console.log('Testing link tracking with URL:', functionUrl);

                // First try with CORS mode
                try {
                    const response = await fetch(functionUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': supabaseKey,
                            'Accept': '*/*'
                        },
                        redirect: 'manual',
                        mode: 'cors'
                    });

                    console.log('Link tracking response:', {
                        status: response.status,
                        headers: Object.fromEntries(response.headers.entries()),
                        ok: response.ok || response.status === 302
                    });

                    if (response.status === 302 || response.status === 307) {
                        const redirectUrl = response.headers.get('Location');
                        showResult('trackingResult', {
                            action: 'Link Tracking Test',
                            status: response.status,
                            trackingId: testId,
                            originalUrl: testUrl,
                            redirectUrl: redirectUrl,
                            url: functionUrl,
                            timestamp: new Date().toISOString()
                        }, 'success');
                        return;
                    }
                } catch (corsError) {
                    console.log('CORS mode failed, trying no-cors:', corsError);
                }

                // If CORS mode failed, try with no-cors and follow redirects
                const response = await fetch(functionUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': supabaseKey,
                        'Accept': '*/*'
                    },
                    redirect: 'follow',
                    mode: 'no-cors'
                });

                // In no-cors mode, we can't access response headers or status
                // but if we get here without an error, it means the request succeeded
                showResult('trackingResult', {
                    action: 'Link Tracking Test',
                    status: 'completed',
                    trackingId: testId,
                    originalUrl: testUrl,
                    url: functionUrl,
                    mode: 'no-cors',
                    timestamp: new Date().toISOString()
                }, 'success');

            } catch (error) {
                console.error('Link tracking error:', error);
                showResult('trackingResult', {
                    action: 'Link Tracking Test',
                    error: error.message,
                    details: error.toString(),
                    url: functionUrl,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testLabelsAPI() {
            if (!currentIntegration) {
                showResult('labelsResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                console.log('Making Gmail Labels API call with token:', {
                    hasAccessToken: !!currentIntegration.access_token,
                    tokenPrefix: currentIntegration.access_token?.substring(0, 10) + '...',
                    expiresAt: currentIntegration.expires_at
                });

                const response = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/labels', {
                    headers: {
                        'Authorization': `Bearer ${currentIntegration.access_token}`
                    }
                });

                const data = await response.json();
                showResult('labelsResult', {
                    action: 'Gmail Labels API Test',
                    status: response.status,
                    labelCount: data.labels?.length || 0,
                    labels: data.labels?.map(l => ({ id: l.id, name: l.name, type: l.type })),
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('labelsResult', {
                    action: 'Gmail Labels API Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function createTestLabel() {
            if (!currentIntegration) {
                showResult('labelsResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                console.log('Creating test label with token:', {
                    hasAccessToken: !!currentIntegration.access_token,
                    tokenPrefix: currentIntegration.access_token?.substring(0, 10) + '...',
                    expiresAt: currentIntegration.expires_at
                });

                const response = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/labels', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentIntegration.access_token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: `CRM-Test-${Date.now()}`,
                        labelListVisibility: 'labelShow',
                        messageListVisibility: 'show'
                    })
                });

                const data = await response.json();
                showResult('labelsResult', {
                    action: 'Create Test Label',
                    status: response.status,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('labelsResult', {
                    action: 'Create Test Label',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function testPhoneNumbers() {
            if (!currentIntegration) {
                showResult('phoneResult', 'Gmail not connected', 'error');
                return;
            }

            try {
                console.log('Making People API call with token:', {
                    hasAccessToken: !!currentIntegration.access_token,
                    tokenPrefix: currentIntegration.access_token?.substring(0, 10) + '...',
                    expiresAt: currentIntegration.expires_at
                });

                const response = await fetch('https://people.googleapis.com/v1/people/me?personFields=phoneNumbers,emailAddresses,names', {
                    headers: {
                        'Authorization': `Bearer ${currentIntegration.access_token}`
                    }
                });

                const data = await response.json();
                showResult('phoneResult', {
                    action: 'Phone Numbers API Test',
                    status: response.status,
                    phoneNumbers: data.phoneNumbers,
                    emailAddresses: data.emailAddresses,
                    names: data.names,
                    response: data,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('phoneResult', {
                    action: 'Phone Numbers API Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        async function runFullTest() {
            showResult('integrationTestResult', 'Running comprehensive tests...', 'info');
            
            const results = {
                timestamp: new Date().toISOString(),
                environment: {
                    supabaseUrl,
                    hasValidConfig: !!supabaseUrl && !!supabaseKey,
                    userAuthenticated: !!userToken,
                    gmailConnected: !!currentIntegration
                },
                integration: currentIntegration ? {
                    provider: currentIntegration.provider,
                    email: currentIntegration.email,
                    scopes: currentIntegration.scope?.split(' ') || [],
                    tokenExpiry: currentIntegration.expires_at,
                    isTokenExpired: new Date(currentIntegration.expires_at) < new Date()
                } : null,
                tests: [],
                dataFlow: {
                    outgoing: [],
                    incoming: []
                },
                scopeUsage: {},
                timing: {},
                errors: []
            };

            // Helper to track API calls
            const trackApiCall = (direction, endpoint, data) => {
                if (direction === 'outgoing') {
                    results.dataFlow.outgoing.push({
                        timestamp: new Date().toISOString(),
                        endpoint,
                        data
                    });
                } else {
                    results.dataFlow.incoming.push({
                        timestamp: new Date().toISOString(),
                        endpoint,
                        data
                    });
                }
            };

            // Test Gmail connection and token
            try {
                const startTime = Date.now();
                const tokenInfoUrl = 'https://www.googleapis.com/oauth2/v1/tokeninfo';
                trackApiCall('outgoing', tokenInfoUrl, { access_token: '***' });
                
                const tokenResponse = await fetch(`${tokenInfoUrl}?access_token=${currentIntegration?.access_token}`);
                const tokenInfo = await tokenResponse.json();
                const tokenTestDuration = Date.now() - startTime;
                
                trackApiCall('incoming', tokenInfoUrl, tokenInfo);
                results.timing.tokenValidation = tokenTestDuration;

                if (tokenInfo.error) {
                    results.tests.push({
                        name: 'Token Validation',
                        status: 'FAIL',
                        error: tokenInfo.error,
                        duration: tokenTestDuration
                    });
                    results.errors.push({
                        component: 'Token Validation',
                        error: tokenInfo.error
                    });
                } else {
                    results.tests.push({
                        name: 'Token Validation',
                        status: 'PASS',
                        scopes: tokenInfo.scope?.split(' ') || [],
                        expiresIn: tokenInfo.expires_in,
                        duration: tokenTestDuration
                    });

                    // Track which scopes are actually being used
                    results.scopeUsage = tokenInfo.scope?.split(' ').reduce((acc, scope) => {
                        acc[scope] = { used: false, endpoints: [] };
                        return acc;
                    }, {});
                }
            } catch (error) {
                results.tests.push({
                    name: 'Token Validation',
                    status: 'ERROR',
                    error: error.message
                });
                results.errors.push({
                    component: 'Token Validation',
                    error: error.message
                });
            }

            // Test Contacts API
            try {
                const startTime = Date.now();
                const contactsUrl = 'https://people.googleapis.com/v1/people/me/connections';
                trackApiCall('outgoing', contactsUrl, {
                    headers: { Authorization: 'Bearer ***' },
                    params: { pageSize: 10, personFields: 'names,emailAddresses,organizations,phoneNumbers' }
                });

                const response = await fetch(`${contactsUrl}?pageSize=10&personFields=names,emailAddresses,organizations,phoneNumbers`, {
                    headers: {
                        'Authorization': `Bearer ${currentIntegration?.access_token}`
                    }
                });

                const data = await response.json();
                const contactTestDuration = Date.now() - startTime;
                
                trackApiCall('incoming', contactsUrl, {
                    status: response.status,
                    contactCount: data.connections?.length || 0,
                    sample: data.connections?.[0] ? {
                        hasName: !!data.connections[0].names,
                        hasEmail: !!data.connections[0].emailAddresses,
                        hasOrg: !!data.connections[0].organizations
                    } : null
                });

                results.timing.contactsFetch = contactTestDuration;
                results.tests.push({
                    name: 'Contacts API',
                    status: response.ok ? 'PASS' : 'FAIL',
                    contactCount: data.connections?.length || 0,
                    duration: contactTestDuration,
                    error: !response.ok ? data.error : undefined
                });

                if (response.ok) {
                    results.scopeUsage['https://www.googleapis.com/auth/contacts.readonly'] = {
                        used: true,
                        endpoints: [contactsUrl]
                    };
                }
            } catch (error) {
                results.tests.push({
                    name: 'Contacts API',
                    status: 'ERROR',
                    error: error.message
                });
                results.errors.push({
                    component: 'Contacts API',
                    error: error.message
                });
            }

            // Test Email Metadata
            try {
                const startTime = Date.now();
                const gmailUrl = 'https://gmail.googleapis.com/gmail/v1/users/me/messages';
                trackApiCall('outgoing', gmailUrl, {
                    headers: { Authorization: 'Bearer ***' },
                    params: { maxResults: 5, q: 'is:unread' }
                });

                const response = await fetch(`${gmailUrl}?maxResults=5&q=is:unread`, {
                    headers: {
                        'Authorization': `Bearer ${currentIntegration?.access_token}`
                    }
                });

                const data = await response.json();
                const emailTestDuration = Date.now() - startTime;
                
                trackApiCall('incoming', gmailUrl, {
                    status: response.status,
                    messageCount: data.messages?.length || 0,
                    sample: data.messages?.[0] ? {
                        hasId: !!data.messages[0].id,
                        hasThreadId: !!data.messages[0].threadId
                    } : null
                });

                results.timing.emailMetadata = emailTestDuration;
                results.tests.push({
                    name: 'Gmail API',
                    status: response.ok ? 'PASS' : 'FAIL',
                    messageCount: data.messages?.length || 0,
                    duration: emailTestDuration,
                    error: !response.ok ? data.error : undefined
                });

                if (response.ok) {
                    results.scopeUsage['https://www.googleapis.com/auth/gmail.readonly'] = {
                        used: true,
                        endpoints: [gmailUrl]
                    };
                }
            } catch (error) {
                results.tests.push({
                    name: 'Gmail API',
                    status: 'ERROR',
                    error: error.message
                });
                results.errors.push({
                    component: 'Gmail API',
                    error: error.message
                });
            }

            // Test Edge Functions
            const edgeFunctions = [
                { name: 'gmail-contacts-preview', endpoint: 'gmail-contacts-preview' },
                { name: 'email-tracker', endpoint: 'email-tracker' },
                { name: 'link-tracker', endpoint: 'link-tracker' }
            ];

            for (const func of edgeFunctions) {
                try {
                    const startTime = Date.now();
                    const functionUrl = `${supabaseUrl}/functions/v1/${func.endpoint}`;
                    
                    // For tracking endpoints, just do a HEAD request
                    const method = func.endpoint.includes('tracker') ? 'HEAD' : 'POST';
                    const body = method === 'POST' ? { accessToken: currentIntegration?.access_token } : undefined;
                    
                    trackApiCall('outgoing', functionUrl, {
                        method,
                        headers: {
                            Authorization: 'Bearer ***',
                            apikey: '***'
                        },
                        body: body ? '***' : undefined
                    });

                    const response = await fetch(functionUrl, {
                        method,
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${userToken}`,
                            'apikey': supabaseKey
                        },
                        body: body ? JSON.stringify(body) : undefined
                    });

                    const functionTestDuration = Date.now() - startTime;
                    let responseData = method === 'HEAD' ? null : await response.json();
                    
                    trackApiCall('incoming', functionUrl, {
                        status: response.status,
                        headers: Object.fromEntries(response.headers.entries()),
                        data: responseData
                    });

                    results.timing[func.name] = functionTestDuration;
                    results.tests.push({
                        name: `Edge Function: ${func.name}`,
                        status: response.ok ? 'PASS' : 'FAIL',
                        duration: functionTestDuration,
                        error: !response.ok ? responseData?.error : undefined
                    });
                } catch (error) {
                    results.tests.push({
                        name: `Edge Function: ${func.name}`,
                        status: 'ERROR',
                        error: error.message
                    });
                    results.errors.push({
                        component: `Edge Function: ${func.name}`,
                        error: error.message
                    });
                }
            }

            // Add summary statistics
            results.summary = {
                totalTests: results.tests.length,
                passed: results.tests.filter(t => t.status === 'PASS').length,
                failed: results.tests.filter(t => t.status === 'FAIL').length,
                errors: results.tests.filter(t => t.status === 'ERROR').length,
                totalDuration: Object.values(results.timing).reduce((a, b) => a + b, 0),
                averageResponseTime: Object.values(results.timing).reduce((a, b) => a + b, 0) / Object.values(results.timing).length
            };

            // Add recommendations based on test results
            results.recommendations = [];
            
            if (results.summary.failed > 0 || results.summary.errors > 0) {
                results.recommendations.push('Some tests failed - check error messages for details');
            }
            
            if (results.integration?.isTokenExpired) {
                results.recommendations.push('Token is expired - refresh token before continuing');
            }
            
            if (results.summary.averageResponseTime > 2000) {
                results.recommendations.push('API response times are high - consider implementing caching');
            }

            const unusedScopes = Object.entries(results.scopeUsage)
                .filter(([_, info]) => !info.used)
                .map(([scope]) => scope);
            
            if (unusedScopes.length > 0) {
                results.recommendations.push(`Found ${unusedScopes.length} unused scopes - consider removing if not needed`);
            }

            showResult('integrationTestResult', results, 
                results.summary.failed === 0 && results.summary.errors === 0 ? 'success' : 'warning');
        }

        async function runQuickTest() {
            showResult('integrationTestResult', 'Running quick health check...', 'info');
            
            const results = {
                timestamp: new Date().toISOString(),
                healthCheck: {
                    gmailConnected: !!currentIntegration,
                    tokenValid: currentIntegration && new Date(currentIntegration.expires_at) > new Date(),
                    requiredScopes: currentIntegration?.scope?.split(' ') || [],
                    edgeFunctionsReachable: false
                }
            };

            // Test if edge functions are reachable
            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-auth`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({ test: true })
                });
                results.healthCheck.edgeFunctionsReachable = true;
                results.healthCheck.edgeFunctionStatus = response.status;
            } catch (error) {
                results.healthCheck.edgeFunctionError = error.message;
            }

            showResult('integrationTestResult', results, 'info');
        }

        function exportTestResults() {
            const results = {
                timestamp: new Date().toISOString(),
                configuration: { supabaseUrl, hasKey: !!supabaseKey },
                integration: currentIntegration,
                scopeAnalysis: {
                    configured: [
                        'auth/gmail.send', 'auth/gmail.readonly', 'auth/contacts.readonly',
                        'auth/contacts.other.readonly', 'auth/user.emails.read',
                        'auth/gmail.modify', 'auth/gmail.labels', 'auth/gmail.metadata',
                        'auth/user.phonenumbers.read', 'auth/gmail.addons.current.message.action',
                        'auth/profile.emails.read'
                    ],
                    currentlyUsed: [
                        'auth/gmail.send', 'auth/gmail.readonly', 'auth/contacts.readonly',
                        'auth/contacts.other.readonly', 'auth/user.emails.read'
                    ],
                    potential: [
                        'auth/gmail.modify', 'auth/gmail.labels', 'auth/gmail.metadata',
                        'auth/user.phonenumbers.read'
                    ]
                }
            };

            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gmail-api-test-results-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showStatus('Test results exported!', 'success');
        }

        async function analyzeSchema() {
            try {
                // Check existing tables and columns
                const tables = ['user_integrations', 'email_tracking', 'contacts', 'companies'];
                const schemaAnalysis = {};

                for (const table of tables) {
                    try {
                        const response = await fetch(`${supabaseUrl}/rest/v1/${table}?limit=1`, {
                            headers: {
                                'Authorization': `Bearer ${userToken}`,
                                'apikey': supabaseKey,
                                'Prefer': 'count=exact'
                            }
                        });

                        if (response.ok) {
                            schemaAnalysis[table] = {
                                exists: true,
                                status: 'OK'
                            };
                        } else {
                            schemaAnalysis[table] = {
                                exists: false,
                                error: response.statusText
                            };
                        }
                    } catch (error) {
                        schemaAnalysis[table] = {
                            exists: false,
                            error: error.message
                        };
                    }
                }

                showResult('schemaResult', {
                    action: 'Database Schema Analysis',
                    tables: schemaAnalysis,
                    timestamp: new Date().toISOString()
                }, 'info');

            } catch (error) {
                showResult('schemaResult', {
                    action: 'Database Schema Analysis',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        function suggestSchemaUpdates() {
            const suggestions = {
                action: 'Schema Update Suggestions',
                timestamp: new Date().toISOString(),
                recommendations: [
                    {
                        table: 'contacts',
                        field: 'phone_numbers',
                        type: 'jsonb',
                        reason: 'Store multiple phone numbers from Google People API',
                        scope: 'user.phonenumbers.read'
                    },
                    {
                        table: 'email_tracking',
                        field: 'gmail_label_ids',
                        type: 'text[]',
                        reason: 'Track Gmail labels applied to sent emails',
                        scope: 'gmail.labels'
                    },
                    {
                        table: 'email_tracking',
                        field: 'gmail_thread_id',
                        type: 'text',
                        reason: 'Link emails to Gmail conversations',
                        scope: 'gmail.readonly'
                    },
                    {
                        table: 'gmail_labels',
                        field: 'new_table',
                        type: 'table',
                        reason: 'Store custom Gmail labels for organization',
                        scope: 'gmail.labels',
                        schema: {
                            id: 'uuid primary key',
                            user_id: 'uuid references auth.users(id)',
                            gmail_label_id: 'text',
                            name: 'text',
                            color: 'text',
                            created_at: 'timestamptz'
                        }
                    },
                    {
                        table: 'user_integrations',
                        field: 'last_sync_timestamp',
                        type: 'timestamptz',
                        reason: 'Track last successful sync for incremental updates',
                        scope: 'gmail.readonly'
                    },
                    {
                        table: 'user_integrations',
                        field: 'sync_settings',
                        type: 'jsonb',
                        reason: 'Store user sync preferences and filters',
                        scope: 'all'
                    }
                ]
            };

            showResult('schemaResult', suggestions, 'warning');
        }

        async function signIn() {
            const email = document.getElementById('userEmail').value;
            const password = document.getElementById('userPassword').value;

            try {
                const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=password`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                console.log('Sign in response:', {
                    status: response.status,
                    ok: response.ok,
                    hasAccessToken: !!data.access_token
                });

                if (response.ok && data.access_token) {
                    userToken = data.access_token;
                    localStorage.setItem('gmail_tester_auth', JSON.stringify({
                        access_token: data.access_token,
                        refresh_token: data.refresh_token,
                        expires_at: new Date(Date.now() + data.expires_in * 1000).toISOString()
                    }));
                    showStatus('Signed in successfully!', 'success');
                    await checkGmailConnection();
                } else {
                    showStatus('Sign in failed: ' + (data.error_description || data.msg), 'error');
                }
            } catch (error) {
                console.error('Sign in error:', error);
                showStatus('Sign in error: ' + error.message, 'error');
            }
        }

        async function signOut() {
            userToken = '';
            localStorage.removeItem('gmail_tester_auth');
            showStatus('Signed out', 'success');
            currentIntegration = null;
            showResult('connectionResult', {
                status: 'Signed Out',
                message: 'Please sign in to continue',
                timestamp: new Date().toISOString()
            }, 'warning');
        }

        // Add token refresh helper
        async function refreshTokenIfNeeded() {
            if (!currentIntegration?.refresh_token) {
                console.log('No refresh token available');
                return false;
            }

            const expiresAt = new Date(currentIntegration.expires_at);
            const fiveMinutesFromNow = new Date(Date.now() + 5 * 60 * 1000);

            if (expiresAt > fiveMinutesFromNow) {
                console.log('Token still valid until:', expiresAt);
                return true;
            }

            console.log('Token expired or expiring soon, refreshing...');
            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/gmail-auth`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({ 
                        refresh_token: currentIntegration.refresh_token 
                    })
                });

                const data = await response.json();
                if (response.ok && data.access_token) {
                    currentIntegration.access_token = data.access_token;
                    currentIntegration.expires_at = data.expires_at;
                    console.log('Token refreshed successfully');
                    return true;
                } else {
                    console.error('Token refresh failed:', data);
                    return false;
                }
            } catch (error) {
                console.error('Error refreshing token:', error);
                return false;
            }
        }

        // Add token check before API calls
        async function makeGmailApiCall(endpoint, options = {}) {
            if (!currentIntegration) {
                throw new Error('Gmail not connected');
            }

            if (!(await refreshTokenIfNeeded())) {
                throw new Error('Failed to refresh expired token');
            }

            const response = await fetch(endpoint, {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${currentIntegration.access_token}`
                }
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API call failed');
            }

            return response.json();
        }

        // ENHANCED: Test stealth email sending
        async function testStealthEmailSend() {
            const email = document.getElementById('stealthTestEmail').value;
            const subject = document.getElementById('stealthTestSubject').value;
            const body = document.getElementById('stealthTestBody').value;

            if (!email || !subject || !body) {
                showResult('stealthSendResult', { error: 'Please fill in all fields' }, 'error');
                return;
            }

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/send-email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey
                    },
                    body: JSON.stringify({
                        userId: 'test-user-id', // Would be actual user ID in production
                        to: email,
                        subject: subject,
                        html: body,
                        trackOpens: true,
                        trackClicks: true
                    })
                });

                const data = await response.json();
                showResult('stealthSendResult', {
                    action: 'Enhanced Stealth Email Send',
                    status: response.status,
                    success: response.ok,
                    enhanced_features: data.enhanced_features || {},
                    tracking_details: {
                        email_id: data.email_id,
                        tracking_pixel_id: data.tracking_pixel_id,
                        links_tracked: data.links_tracked
                    },
                    labels_applied: data.enhanced_features?.labels_applied || 0,
                    timestamp: new Date().toISOString(),
                    full_response: data
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('stealthSendResult', {
                    action: 'Enhanced Stealth Email Send',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        // ENHANCED: Test Gmail labels functionality
        async function testGmailLabelsFeature() {
            try {
                if (!currentIntegration) {
                    throw new Error('Gmail not connected');
                }

                showResult('labelsResult', {
                    action: 'Testing Gmail Labels Feature',
                    message: 'This feature is automatically tested when sending emails',
                    expected_labels: [
                        'CRM-Sent (for all CRM emails)',
                        'CRM-Campaign-[ID] (for campaign emails)'
                    ],
                    instructions: [
                        '1. Send an enhanced email using the button above',
                        '2. Check your Gmail account',
                        '3. Look for new labels in the left sidebar',
                        '4. Verify the sent email appears under CRM-Sent'
                    ],
                    timestamp: new Date().toISOString()
                }, 'info');

            } catch (error) {
                showResult('labelsResult', {
                    action: 'Gmail Labels Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        // ENHANCED: List Gmail labels
        async function listGmailLabels() {
            try {
                if (!currentIntegration) {
                    throw new Error('Gmail not connected');
                }

                const labelsData = await makeGmailApiCall('https://gmail.googleapis.com/gmail/v1/users/me/labels');
                
                const crmLabels = labelsData.labels.filter(label => 
                    label.name.startsWith('CRM-') || 
                    label.name.includes('Campaign')
                );

                showResult('labelsResult', {
                    action: 'Gmail Labels List',
                    total_labels: labelsData.labels.length,
                    crm_labels: crmLabels,
                    all_labels: labelsData.labels.map(l => ({
                        id: l.id,
                        name: l.name,
                        type: l.type
                    })),
                    timestamp: new Date().toISOString()
                }, 'success');

            } catch (error) {
                showResult('labelsResult', {
                    action: 'Gmail Labels List',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        // ENHANCED: Test enhanced analytics
        async function testEnhancedAnalytics() {
            try {
                const response = await fetch(`${supabaseUrl}/rest/v1/email_tracking?select=*&order=created_at.desc&limit=10`, {
                    headers: {
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                showResult('enhancedAnalyticsResult', {
                    action: 'Enhanced Analytics Test',
                    status: response.status,
                    tracking_records: data.length,
                    recent_emails: data.map(record => ({
                        email_id: record.email_id,
                        recipient: record.recipient,
                        sent_at: record.sent_at,
                        has_tracking_pixel: !!record.tracking_pixel_id,
                        open_count: record.open_count,
                        click_count: record.click_count
                    })),
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('enhancedAnalyticsResult', {
                    action: 'Enhanced Analytics Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        // ENHANCED: Simulate email opens for testing
        async function simulateEmailOpens() {
            try {
                // Get the most recent email tracking record
                const response = await fetch(`${supabaseUrl}/rest/v1/email_tracking?select=*&order=created_at.desc&limit=1`, {
                    headers: {
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (data.length === 0) {
                    throw new Error('No email tracking records found. Send an email first.');
                }

                const trackingRecord = data[0];
                
                if (!trackingRecord.tracking_pixel_id) {
                    throw new Error('No tracking pixel ID found for the most recent email.');
                }

                // Simulate tracking pixel access
                const pixelResponse = await fetch(`${supabaseUrl}/functions/v1/email-tracker?id=${trackingRecord.tracking_pixel_id}`);

                showResult('enhancedAnalyticsResult', {
                    action: 'Simulated Email Open',
                    tracking_pixel_id: trackingRecord.tracking_pixel_id,
                    pixel_response_status: pixelResponse.status,
                    email_id: trackingRecord.email_id,
                    recipient: trackingRecord.recipient,
                    message: 'Open event should be recorded in analytics',
                    timestamp: new Date().toISOString()
                }, pixelResponse.ok ? 'success' : 'error');

            } catch (error) {
                showResult('enhancedAnalyticsResult', {
                    action: 'Simulate Email Opens',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }

        // ENHANCED: Verify tracking pixel stealth
        async function verifyTrackingPixel() {
            showResult('trackingVerifyResult', {
                action: 'Tracking Pixel Stealth Verification',
                enhanced_attributes: {
                    position: 'absolute',
                    left: '-9999px',
                    top: '-9999px', 
                    visibility: 'hidden',
                    opacity: '0',
                    border: '0',
                    outline: '0'
                },
                placement: 'Before </body> tag for natural integration',
                stealth_features: [
                    'Invisible to recipient (off-screen positioning)',
                    'Hidden from view (visibility:hidden + opacity:0)',
                    'No visual impact (border:0, outline:0)',
                    'Lazy loading attribute for natural behavior'
                ],
                verification_steps: [
                    '1. Send test email with enhanced tracking',
                    '2. Check received email HTML source',
                    '3. Look for tracking pixel before </body>',
                    '4. Verify pixel has stealth attributes',
                    '5. Confirm pixel is not visible when email is opened'
                ],
                bypass_techniques: [
                    'Absolute positioning moves pixel off-screen',
                    'Multiple hiding attributes for redundancy',
                    'Natural placement in email structure',
                    'Personal headers reduce spam filtering'
                ],
                timestamp: new Date().toISOString()
            }, 'info');
        }

        // ENHANCED: Test link tracking
        async function testLinkTracking() {
            try {
                const response = await fetch(`${supabaseUrl}/rest/v1/tracked_links?select=*&order=created_at.desc&limit=5`, {
                    headers: {
                        'Authorization': `Bearer ${userToken}`,
                        'apikey': supabaseKey,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                showResult('trackingVerifyResult', {
                    action: 'Link Tracking Test',
                    status: response.status,
                    tracked_links_count: data.length,
                    recent_links: data.map(link => ({
                        tracking_id: link.tracking_id,
                        original_url: link.original_url,
                        email_id: link.email_id,
                        created_at: link.created_at
                    })),
                    test_instructions: [
                        '1. Send email with links using enhanced send',
                        '2. Recipient clicks on links in email',
                        '3. Clicks are redirected through tracking URL',
                        '4. Original URL is accessed after tracking',
                        '5. Click events are recorded in analytics'
                    ],
                    tracking_pattern: `${supabaseUrl}/functions/v1/link-tracker?id=[TRACKING_ID]&url=[ENCODED_URL]`,
                    timestamp: new Date().toISOString()
                }, response.ok ? 'success' : 'error');

            } catch (error) {
                showResult('trackingVerifyResult', {
                    action: 'Link Tracking Test',
                    error: error.message,
                    timestamp: new Date().toISOString()
                }, 'error');
            }
        }
    </script>
</body>
</html> 