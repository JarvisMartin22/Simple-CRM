import { useState, useCallback } from 'react';
import { useContacts } from '@/contexts/ContactsContext';
import { useAuth } from '@/contexts/AuthContext';
import { toast } from '@/components/ui/use-toast';
import { supabase } from '@/integrations/supabase/client';

interface ImportProgress {
  total: number;
  processed: number;
  successful: number;
  failed: number;
}

export function useGmailContactsImport() {
  const { createContact } = useContacts();
  const { user } = useAuth();
  const [isImporting, setIsImporting] = useState(false);
  const [includeNoEmail, setIncludeNoEmail] = useState(false);
  const [importProgress, setImportProgress] = useState<ImportProgress>({
    total: 0,
    processed: 0,
    successful: 0,
    failed: 0
  });

  const importFromGmail = useCallback(async () => {
    try {
      setIsImporting(true);
      setImportProgress({
        total: 0,
        processed: 0,
        successful: 0,
        failed: 0
      });
      
      // Try to fix the tags column if needed
      try {
        console.log('Checking and fixing tags column...');
        await supabase.rpc('execute_sql', {
          sql_query: `
            -- Try to fix the tags column default value if not already set correctly
            DO $$
            BEGIN
              BEGIN
                ALTER TABLE contacts ALTER COLUMN tags SET DEFAULT '{}';
              EXCEPTION WHEN OTHERS THEN
                NULL;
              END;
              
              BEGIN
                UPDATE contacts SET tags = '{}' WHERE tags IS NULL;
              EXCEPTION WHEN OTHERS THEN
                NULL;
              END;
            END $$;
          `
        });
        console.log('Column check/fix completed');
      } catch (fixError) {
        console.error('Error trying to fix schema:', fixError);
      }

      // First check if Gmail is connected
      const { data: integration, error: integrationError } = await supabase
        .from('user_integrations')
        .select('id, access_token, refresh_token, expires_at')
        .eq('provider', 'gmail')
        .maybeSingle();

      if (integrationError) {
        console.error('Failed to check Gmail integration:', integrationError);
        throw new Error('Failed to check Gmail integration');
      }

      if (!integration) {
        throw new Error('Gmail is not connected. Please connect Gmail first.');
      }

      console.log('Found Gmail integration:', {
        id: integration.id,
        hasAccessToken: !!integration.access_token,
        hasRefreshToken: !!integration.refresh_token,
        expiresAt: integration.expires_at
      });

      // Call the Gmail contacts import function
      const response = await fetch(`${import.meta.env.VITE_SUPABASE_FUNCTIONS_URL}/gmail-contacts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`,
          'X-Gmail-Token': integration.access_token
        },
        body: JSON.stringify({
          integration_id: integration.id,
          access_token: integration.access_token,
          refresh_token: integration.refresh_token,
          include_no_email: includeNoEmail
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        console.error('Gmail contacts import failed:', { 
          status: response.status, 
          statusText: response.statusText,
          data: errorData,
          headers: Object.fromEntries(response.headers.entries())
        });
        throw new Error('Failed to fetch Gmail contacts: ' + response.statusText);
      }

      const data = await response.json();
      console.log('Received contacts data:', {
        totalContacts: data.contacts?.length || 0,
        firstContact: data.contacts?.[0] ? {
          hasName: !!(data.contacts[0].firstName || data.contacts[0].lastName),
          hasEmail: !!data.contacts[0].email,
          hasCompany: !!data.contacts[0].company,
          fullContact: data.contacts[0]
        } : null
      });
      const contacts = data.contacts || [];

      // Process each contact
      let successful = 0;
      let failed = 0;
      const total = contacts.length;

      for (let i = 0; i < contacts.length; i++) {
        const contact = contacts[i];
        try {
          const userId = (await supabase.auth.getUser()).data.user?.id;
          const companyName = contact.company || contact.organizations?.[0]?.name;
          let companyId = null;

          // Check if source column exists by querying schema
          const { data: columns, error: schemaError } = await supabase
            .from('contacts')
            .select('*')
            .limit(1);
          
          const hasSourceColumn = columns && columns[0] && 'source' in columns[0];
          const hasTagsColumn = columns && columns[0] && 'tags' in columns[0];
          console.log('Schema check - source column exists:', hasSourceColumn);
          console.log('Schema check - tags column exists:', hasTagsColumn);

          // If we have a company name, try to find or create the company
          if (companyName && userId) {
            // Try to find existing company
            const { data: existingCompanies } = await supabase
              .from('companies')
              .select('id')
              .eq('user_id', userId)
              .eq('name', companyName)
              .maybeSingle();

            if (existingCompanies) {
              companyId = existingCompanies.id;
            } else {
              // Create new company
              const { data: newCompany, error: companyError } = await supabase
                .from('companies')
                .insert({
                  user_id: userId,
                  name: companyName,
                  website: contact.website || contact.urls?.[0]?.value || null
                })
                .select('id')
                .single();

              if (!companyError && newCompany) {
                companyId = newCompany.id;
              }
            }
          }

          // Insert contact
          const contactData: Record<string, any> = {
            user_id: userId,
            first_name: contact.firstName || contact.names?.[0]?.givenName || '',
            last_name: contact.lastName || contact.names?.[0]?.familyName || '',
            email: contact.email || contact.emailAddresses?.[0]?.value || '',
            phone: contact.phone || contact.phoneNumbers?.[0]?.value || '',
            title: contact.title || contact.organizations?.[0]?.title || '',
            company_id: companyId,
            website: contact.website || contact.urls?.[0]?.value || ''
          };
          
          // Add source field if it exists in the schema
          if (hasSourceColumn) {
            contactData.source = 'gmail';
          }

          // Try different approaches - first try removing tags completely
          /*
          // Add detailed debugging for tags
          if (hasTagsColumn) {
            console.log('Adding tags field to contact data');
            // Try different formats
            const tagFormats = {
              emptyArray: [],
              jsArray: ["gmail-import"],
              pgEmptyArray: "{}",
              pgArray: "{gmail-import}",
              nullValue: null
            };
            
            // Try format 1 first
            contactData.tags = tagFormats.jsArray;
          }
          */
          
          console.log(`Inserting contact ${i+1}/${contacts.length}:`, JSON.stringify(contactData));
          
          // Try regular insert first
          const { error: insertError } = await supabase.from('contacts').insert(contactData);

          if (insertError) {
            console.error('Failed to insert contact:', {
              error: insertError,
              code: insertError.code,
              message: insertError.message,
              details: insertError.details,
              tagsValue: contactData.tags,
              tagsType: typeof contactData.tags
            });
            
            // If array error, try direct SQL query as fallback
            if (insertError.code === '22P02' && insertError.message.includes('array')) {
              console.log('Trying direct SQL query as fallback');
              
              // Try a simplified record with only required fields
              const simplifiedContact = {
                user_id: userId,
                first_name: contact.firstName || '',
                last_name: contact.lastName || '',
                email: contact.email || '',
              };
              
              console.log('Trying simplified contact without tags:', simplifiedContact);
              
              const { error: simpleError } = await supabase
                .from('contacts')
                .insert(simplifiedContact);
              
              if (simpleError) {
                console.error('Simplified insert also failed:', simpleError);
                
                // Now try the stored procedure as final fallback
                const { firstName, lastName, email, phone, title, website } = contact;
                
                // Use direct SQL with proper array syntax
                const { data: sqlResult, error: sqlError } = await supabase.rpc(
                  'create_contact',
                  {
                    p_user_id: userId,
                    p_first_name: firstName || '',
                    p_last_name: lastName || '',
                    p_email: email || '',
                    p_phone: phone || '',
                    p_title: title || '',
                    p_company_id: companyId,
                    p_website: website || '',
                    p_notes: '',
                    p_tags: ['gmail-import']
                  }
                );
                
                if (sqlError) {
                  console.error('SQL fallback also failed:', sqlError);
                  failed++;
                } else {
                  console.log('SQL fallback succeeded:', sqlResult);
                  successful++;
                }
              } else {
                console.log('Simplified insert succeeded!');
                successful++;
              }
            } else {
              failed++;
            }
          } else {
            successful++;
          }

          setImportProgress({
            total,
            processed: i + 1,
            successful,
            failed
          });
        } catch (error) {
          console.error('Error processing contact:', error);
          failed++;
          setImportProgress(prev => ({
            ...prev,
            processed: i + 1,
            failed: prev.failed + 1
          }));
        }
      }

      toast({
        title: 'Import Complete',
        description: `Successfully imported ${successful} contacts. ${failed} failed.`
      });

    } catch (error) {
      console.error('Gmail contact import failed:', error);
      toast({
        title: 'Import Failed',
        description: error instanceof Error ? error.message : 'Failed to import contacts',
        variant: 'destructive'
      });
    } finally {
      setIsImporting(false);
    }
  }, [includeNoEmail]);

  return {
    importFromGmail,
    isImporting,
    importProgress,
    includeNoEmail,
    setIncludeNoEmail
  };
}

export default useGmailContactsImport;
