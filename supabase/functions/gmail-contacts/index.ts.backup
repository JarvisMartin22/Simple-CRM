import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { corsHeaders } from "../_shared/cors.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.21.0';

// Create a Supabase client
const supabaseUrl = Deno.env.get("SUPABASE_URL") as string;
const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") as string;
const supabase = createClient(supabaseUrl, supabaseServiceKey);

interface Contact {
  names?: Array<{
    metadata?: { primary?: boolean };
    givenName?: string;
    familyName?: string;
  }>;
  emailAddresses?: Array<{
    metadata?: { primary?: boolean };
    value?: string;
  }>;
  organizations?: Array<{
    metadata?: { primary?: boolean };
    name?: string;
    title?: string;
  }>;
  phoneNumbers?: Array<{
    metadata?: { primary?: boolean };
    value?: string;
  }>;
  urls?: Array<{
    metadata?: { primary?: boolean };
    value?: string;
  }>;
  resourceName?: string;
}

// Function to fetch main contacts
const fetchMainContacts = async (accessToken: string): Promise<{ success: boolean; data: Contact[]; error?: string }> => {
  try {
    console.log("Fetching main contacts...");
    const contactsUrl = 'https://people.googleapis.com/v1/people/me/connections?pageSize=1000&personFields=names,emailAddresses,phoneNumbers,organizations,urls,metadata,photos';
    
    const response = await fetch(contactsUrl, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    });
    
    if (!response.ok) {
      const error = await response.text();
      console.error(`Error fetching main contacts: ${response.status}`, error);
      return { success: false, data: [], error };
    }
    
    const data = await response.json();
    console.log(`Found ${data.connections?.length || 0} main contacts`);
    return { 
      success: true, 
      data: data.connections || []
    };
  } catch (error) {
    console.error("Error fetching main contacts:", error);
    return { success: false, data: [], error: error.message };
  }
};

// Function to fetch other contacts
const fetchOtherContacts = async (accessToken: string): Promise<{ success: boolean; data: Contact[]; error?: string }> => {
  try {
    console.log("Fetching other contacts...");
    const otherContactsUrl = 'https://people.googleapis.com/v1/otherContacts?pageSize=1000&readMask=names,emailAddresses,phoneNumbers,organizations,urls,metadata,photos';
    
    const response = await fetch(otherContactsUrl, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    });
    
    if (!response.ok) {
      const error = await response.text();
      console.error(`Error fetching other contacts: ${response.status}`, error);
      return { success: false, data: [], error };
    }
    
    const data = await response.json();
    console.log(`Found ${data.otherContacts?.length || 0} other contacts`);
    return { 
      success: true, 
      data: data.otherContacts || []
    };
  } catch (error) {
    console.error("Error fetching other contacts:", error);
    return { success: false, data: [], error: error.message };
  }
};

// Main handler for the edge function
serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: {
        ...corsHeaders,
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Gmail-Token, X-Client-Info, apikey, x-api-key, range, cache-control, x-supabase-auth, x-auth-token, Accept, Origin, Referer, User-Agent'
      }
    });
  }

  try {
    // Get the Gmail token from the header
    const gmailToken = req.headers.get('X-Gmail-Token');
    console.log('Gmail token present:', !!gmailToken);
    if (!gmailToken) {
      throw new Error('No Gmail token provided');
    }

    // Get the request body
    const { integration_id, access_token, refresh_token, include_no_email = false } = await req.json();
    console.log('Request params:', { 
      has_integration_id: !!integration_id,
      has_access_token: !!access_token,
      has_refresh_token: !!refresh_token,
      include_no_email
    });

    if (!integration_id) {
      throw new Error('No integration ID provided');
    }

    if (!access_token) {
      throw new Error('No access token provided');
    }

    const contacts: Contact[] = [];

    // Fetch main contacts
    console.log("Starting main contacts fetch with access token:", access_token.substring(0, 10) + '...');
    const mainContactsResult = await fetchMainContacts(access_token);
    if (mainContactsResult.success) {
      console.log(`Successfully fetched ${mainContactsResult.data.length} main contacts`);
      contacts.push(...mainContactsResult.data);
    } else {
      console.error('Failed to fetch main contacts:', mainContactsResult.error);
    }

    // Fetch other contacts
    console.log("Starting other contacts fetch...");
    const otherContactsResult = await fetchOtherContacts(access_token);
    if (otherContactsResult.success) {
      console.log(`Successfully fetched ${otherContactsResult.data.length} other contacts`);
      contacts.push(...otherContactsResult.data);
    } else {
      console.error('Failed to fetch other contacts:', otherContactsResult.error);
    }

    console.log(`Total contacts before processing: ${contacts.length}`);
    console.log('First few contacts:', contacts.slice(0, 2).map(c => ({
      hasNames: !!c.names?.length,
      hasEmail: !!c.emailAddresses?.length,
      resourceName: c.resourceName
    })));

    if (contacts.length === 0) {
      return new Response(JSON.stringify({
        contacts: []
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    // Process the contacts
    const processedContacts = contacts.map((contact: Contact) => {
      const primaryName = contact.names ? contact.names.find(n => n.metadata?.primary) || contact.names[0] : null;
      const primaryEmail = contact.emailAddresses ? contact.emailAddresses.find(e => e.metadata?.primary) || contact.emailAddresses[0] : null;
      const primaryOrg = contact.organizations ? contact.organizations.find(o => o.metadata?.primary) || contact.organizations[0] : null;
      const primaryPhone = contact.phoneNumbers ? contact.phoneNumbers.find(p => p.metadata?.primary) || contact.phoneNumbers[0] : null;
      const primaryUrl = contact.urls ? contact.urls.find(u => u.metadata?.primary) || contact.urls[0] : null;
      
      return {
        firstName: primaryName?.givenName || '',
        lastName: primaryName?.familyName || '',
        email: primaryEmail?.value || '',
        phone: primaryPhone?.value || '',
        title: primaryOrg?.title || '',
        company: primaryOrg?.name || '',
        website: primaryUrl?.value || '',
        names: contact.names || [],
        emailAddresses: contact.emailAddresses || [],
        phoneNumbers: contact.phoneNumbers || [],
        organizations: contact.organizations || [],
        urls: contact.urls || []
      };
    }).filter(contact => !include_no_email || contact.email); // Only include contacts with email if include_no_email is false

    console.log(`Total contacts after processing: ${processedContacts.length}`);

    // Return the processed contacts
    return new Response(JSON.stringify({
      contacts: processedContacts
    }), {
      headers: { 
        ...corsHeaders, 
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Gmail-Token, X-Client-Info, apikey, x-api-key, range, cache-control, x-supabase-auth, x-auth-token, Accept, Origin, Referer, User-Agent'
      },
      status: 200,
    });

  } catch (error) {
    console.error('Error in request:', error);
    return new Response(JSON.stringify({
      error: error.message
    }), {
      headers: { 
        ...corsHeaders, 
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Gmail-Token, X-Client-Info, apikey, x-api-key, range, cache-control, x-supabase-auth, x-auth-token, Accept, Origin, Referer, User-Agent'
      },
      status: 400,
    });
  }
}); 